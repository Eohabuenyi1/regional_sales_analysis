# -*- coding: utf-8 -*-
"""Regional Sales Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D9ikh-I-Dup0_kK_atFtEzlJLSdh31un

### ****Problem Statement****

To identify key revenue and profit drivers accross products, channels, and regions, uncover seasonal trends and outliers, and align performance against budgets. use  thses insight to optimize pricing, promotion and market expansion for sustainable growth and reduce concenteration risk
"""

### ***Importing Libraries***
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sheets = pd.read_excel('/content/Regional Sales Dataset (1).xlsx',sheet_name=None)

# Assign Dataframe to each sheet

df_sales = sheets['Sales Orders']
df_customers = sheets['Customers']
df_products = sheets['Products']
df_regions = sheets['Regions']
df_state_reg = sheets['State Regions']
df_budgets = sheets['2017 Budgets']

df_sales.head()

df_sales.shape

print('df_sales shape: ',(df_sales.shape))
print('df_customers shape:',(df_customers.shape))
print('df_products Shape:',(df_products.shape))
print('df_regions shape:',(df_regions.shape))
print('df_state_reg:',(df_state_reg.shape))
print('df_budgets:',(df_budgets.shape))

df_sales.head()



df_customers.head()

df_products.head()

df_regions.head()

df_state_reg.head()

new_header = df_state_reg.iloc[0]
df_state_reg.columns = new_header
df_state_reg = df_state_reg[1:].reset_index(drop=True)

df_state_reg.head()

df_budgets.head()

df_sales.isnull().sum()

df_state_reg.isnull().sum()

df_regions.isnull().sum()

df_customers.isnull().sum()

df_budgets.isnull().sum()

"""# Data Cleaning and Wrangling

"""

# Merge with Customers

df = df_sales.merge(
    df_customers,
    how='left',
    left_on='Customer Name Index',
    right_on='Customer Index'
    )

df_sales.head()



# Merge with Product

df = df.merge(
    df_products,
    how='left',
    left_on='Product Description Index',
    right_on='Index'
    )

df.head(5)

# Merge with Region

df = df.merge(
    df_regions,
    how='left',
    left_on='Delivery Region Index',
    right_on='id'
    )

df.head(5)

# Merge with State Region

df = df.merge(
    df_state_reg[["State Code","Region"]],
    how='left',
    left_on='state_code',
    right_on='State Code'
    )

df.head(5)

# Merge with Budget

df = df.merge(
    df_budgets,
    how='left',
    on='Product Name'
    )

df.head(5)

#Customer Index
#Index
#id
#State Code

# Clean up redundant columns
cols_to_drop = ['Customer Index','Index','id','State Code']
df=df.drop(columns = cols_to_drop,errors='ignore')

df.head(5)

# Convert all column to lower case for consistency and easy access
df.columns = df.columns.str.lower()

df.columns.values

# Keep Important Columns

cols_to_keep = [
    'ordernumber',
    'orderdate',
    'channel',
    'delivery region index',
    'product description index',
    'order quantity',
    'unit price',
    'total unit cost',
    'product name',
    'longitude',
    'state_code',
    'state',
    'line total',
    'county',
    'region',
    'latitude',
    'population',
    '2017 budgets']

df = df[cols_to_keep]

df.head(5)

df.tail(1)

# Rename Colmmn
df = df.rename(columns={
    'ordernumber':'order_number',
    'orderdate':'order_date',
    'delivery region index':'delivery_region_index',
    'product description index':'product_description_index',
    'order quantity':'order_quantity',
    'unit price':'unit_price',
    'state_code':'state',
    'state':'state_name',
    'total unit cost':'total_unit_cost',
    'product name':'product_name',
    'line total':'revenue',
    '2017 budgets':'budget',
    })

df.head(1)

df.info()

df.to_csv('final.csv')

df.head(1)

df['total_cost'] = df['order_quantity'] * df['total_unit_cost']

df['profit'] = df['revenue'] - df['total_cost']

df['profit_margin_pct'] = df['profit']/df['revenue']*100

df.head(5)

"""# EDA"""

# Ensure order_date is a datetime column, coercing errors
df['order_date'] = pd.to_datetime(df['order_date'], errors='coerce')

# Drop rows where order_date is NaT after coercion
df.dropna(subset=['order_date'], inplace=True)

# Extract year-month for grouping
df['year_month'] = df['order_date'].dt.to_period('M')

# Aggregate revenue (or total_cost/profit, depending on your need)
monthly_sales = df.groupby('year_month')['revenue'].sum().reset_index()

# Convert back to datetime for plotting
monthly_sales['year_month'] = monthly_sales['year_month'].dt.to_timestamp()

# Plot the line chart
plt.figure(figsize=(10, 6))
plt.plot(monthly_sales['year_month'], monthly_sales['revenue'], marker='o', linewidth=2)

# Add titles and labels
plt.title('Monthly Sales Trend', fontsize=14)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Revenue', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)

# Optional: format x-axis ticks for better readability
plt.xticks(rotation=45)
plt.tight_layout()

# Show the plot
plt.show()

# Ensure order_date is a datetime column
df['order_date'] = pd.to_datetime(df['order_date'])

# Define the date range to remove
start_remove = '2024-01-01'
end_remove = '2024-02-29'

# Filter out those records
df_new = df[~df['order_date'].between(start_remove, end_remove)]

# Ensure order_date is in datetime format
df_new['order_date'] = pd.to_datetime(df_new['order_date'])

# Extract month as a number and name
df_new['month'] = df_new['order_date'].dt.month
df_new['month_name'] = df_new['order_date'].dt.strftime('%b')

# Aggregate revenue across all years for each calendar month
monthly_seasonality = (
    df_new.groupby(['month', 'month_name'])['revenue']
    .sum()
    .reset_index()
    .sort_values('month')
)

# Plot the seasonality trend
plt.figure(figsize=(10, 6))
plt.plot(monthly_seasonality['month_name'], monthly_seasonality['revenue'], marker='o', linewidth=2)

# Add titles and labels
plt.title('Overall Monthly Sales Seasonality (All Years Combined)', fontsize=14)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Total Revenue', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)

# Show the plot
plt.tight_layout()
plt.show()

# Assuming df is your DataFrame
# Example: df = pd.read_csv('your_file.csv')

# --- Step 1: Convert order_date to datetime (if not already) ---
df_new['order_date'] = pd.to_datetime(df_new['order_date'], errors='coerce')

# --- Step 2: Extract the year ---
df_new['year'] = df_new['order_date'].dt.year

# --- Step 3: Choose the year of interest (e.g., most recent year) ---
latest_year = df_new['year'].max()

# --- Step 4: Filter data for that year ---
df_year = df_new[df_new['year'] == latest_year]

# --- Step 5: Group by product_name and sum the revenue ---
top_products = (
    df_year.groupby('product_name')['revenue']
    .sum()
    .sort_values(ascending=False)
    .head(10)
)

# --- Step 6: Plot the chart ---
plt.figure(figsize=(10, 6))
top_products.plot(kind='bar', color='skyblue', edgecolor='black')

plt.title(f"Top 10 Products by Revenue in {latest_year}",fontsize=14)
plt.xlabel("Product Name",fontsize=12)
plt.ylabel("Total Revenue")
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# --- 1. Create Sample DataFrame (Replace this section with your actual data loading) ---
def create_sample_dataframe(num_rows=1000, num_products=50):
    """Creates a sample DataFrame matching the user's schema for demonstration."""
    product_names = [f'Product_{i}' for i in range(1, num_products + 1)]

    # Generate random data
    data = {
        'order_number': np.arange(1, num_rows + 1),
        'order_date': pd.to_datetime(pd.date_range(start='2024-01-01', periods=num_rows, freq='H').to_numpy().reshape(-1)),
        'channel': np.random.choice(['Online', 'Retail', 'Wholesale'], num_rows),
        'product_name': np.random.choice(product_names, num_rows),
        'order_quantity': np.random.randint(1, 10, num_rows),
        'unit_price': np.round(np.random.uniform(5, 50, num_rows), 2),
    }

    df_new = pd.DataFrame(data)

    # Calculate revenue (making sure to simulate low performance for some products)
    df_new['revenue'] = df_new['order_quantity'] * df_new['unit_price']

    # Introduce some genuinely low-performing products to guarantee we get 10 low performers
    low_performers = ['Product_1', 'Product_2', 'Product_3', 'Product_4', 'Product_5', 'Product_6', 'Product_7', 'Product_8', 'Product_9', 'Product_10']
    for prod in low_performers:
        mask = df_new['product_name'] == prod
        # Artificially lower the revenue for these specific products
        df_new.loc[mask, 'revenue'] = df_new.loc[mask, 'revenue'] * np.random.uniform(0.1, 0.5)

    return df

# Load the sample data (Replace this line with `df = pd.read_csv('your_data.csv')` or similar)
df_new = create_sample_dataframe()
print("Sample DataFrame created successfully.")
print(f"Total Unique Products: {df_new['product_name'].nunique()}")


# --- 2. Group and Aggregate Revenue ---
# Calculate the total revenue for each product
product_revenue = df_new.groupby('product_name')['revenue'].sum().reset_index()
product_revenue = product_revenue.sort_values(by='revenue', ascending=False)


# --- 3. Find Bottom Ten Products ---
# Sort by revenue ascending (worst performers first) and select the top 10
bottom_ten = product_revenue.nsmallest(10, 'revenue')

print("\n--- Bottom Ten Products by Revenue ---")
print(bottom_ten)


# --- 4. Visualize the Bottom Ten ---
if not bottom_ten.empty:
    # Ensure the lowest revenue product is at the bottom of the chart for better reading
    bottom_ten_sorted = bottom_ten.sort_values(by='revenue', ascending=True)

    plt.style.use('seaborn-v0_8-darkgrid')
    fig, ax = plt.subplots(figsize=(10, 6))

    # Create the horizontal bar chart
    bars = ax.barh(
        bottom_ten_sorted['product_name'],
        bottom_ten_sorted['revenue'],
        color='#dc2626' # Red color for poor performance
    )

    # Add labels and title
    ax.set_title('Bottom 10 Products by Total Revenue (YTD)', fontsize=16, fontweight='bold', pad=20)
    ax.set_xlabel('Total Revenue (USD)', fontsize=12)
    ax.set_ylabel('Product Name', fontsize=12)
    ax.tick_params(axis='both', which='major', labelsize=10)

    # Format x-axis ticks to be currency-like (e.g., $1,000)
    formatter = plt.FuncFormatter(lambda x, p: f'${x:,.0f}')
    ax.xaxis.set_major_formatter(formatter)

    # Add value labels to the bars
    for bar in bars:
        width = bar.get_width()
        label = f'${width:,.2f}'
        ax.text(
            width,
            bar.get_y() + bar.get_height() / 2,
            label,
            ha='left',  # horizontal alignment
            va='center', # vertical alignment
            fontsize=10,
            color='black'
        )

    plt.tight_layout()
    plt.show()

# Sales by channel



# Load the sample data (Replace this line with your actual data loading)
df_new = create_sample_dataframe()


# --- 2. Group and Aggregate Revenue by Channel ---
channel_revenue = df_new.groupby('channel')['revenue'].sum().reset_index()
channel_revenue = channel_revenue.sort_values(by='revenue', ascending=False)


# --- 3. Identify Top Three Channels ---
top_three_channels = channel_revenue.head(3)

print("--- Top 3 Sales Channels by Revenue ---")
print(top_three_channels)


# --- 4. Visualize the Top Three in a Pie Chart ---

if not top_three_channels.empty:
    labels = top_three_channels['channel']
    sizes = top_three_channels['revenue']

    # Custom labels to include percentage and total revenue (simulating tooltip data)
    def make_autopct(values):
        def my_autopct(pct):
            total = sum(values)
            val = pct*total/100.0
            # Format: Channel Name (Percentage, $Total)
            return f'{pct:.1f}%\n(${val:,.0f})'
        return my_autopct

    # Define colors for different slices
    colors = ['#3498db', '#2ecc71', '#f1c40f'] # Blue, Green, Yellow

    plt.style.use('seaborn-v0_8-whitegrid')
    fig, ax = plt.subplots(figsize=(9, 9))

    # Create the pie chart
    wedges, texts, autotexts = ax.pie(
        sizes,
        labels=labels,
        autopct=make_autopct(sizes),
        startangle=90,
        colors=colors,
        explode=[0.05, 0, 0], # Explode the largest slice for emphasis
        textprops={'fontsize': 12, 'color': 'black'}
    )

    # Set title and equal aspect ratio
    ax.set_title('Top 3 Sales Channels by Revenue (YTD)', fontsize=18, fontweight='bold', pad=20)
    ax.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle.

    plt.tight_layout()
    plt.show()

# Load the sample data (Replace this line with your actual data loading)
df_new = create_sample_dataframe(num_rows=2000) # Increased rows for a better distribution


# --- 2. Calculate Order Totals (AOV Distribution) ---
# AOV Distribution is the total revenue for each unique order number.
order_totals = df_new.groupby('order_number')['revenue'].sum().reset_index()
order_totals.rename(columns={'revenue': 'order_total'}, inplace=True)

# Calculate the overall Average Order Value (AOV) for annotation
overall_aov = order_totals['order_total'].mean()

print(f"Overall Average Order Value (AOV): ${overall_aov:,.2f}")
print(f"Total Unique Orders: {order_totals.shape[0]}")


# --- 3. Visualize the Distribution (Histogram) ---

plt.style.use('seaborn-v0_8-darkgrid')
fig, ax = plt.subplots(figsize=(12, 6))

# Define number of bins for the histogram
n_bins = 20

# Generate the histogram data
counts, bin_edges, patches = ax.hist(
    order_totals['order_total'],
    bins=n_bins,
    edgecolor='black',
    alpha=0.75,
    color='#1f77b4' # Uniform color for distribution
)

# --- 4. Apply Tooltips (Data Labels) and Formatting ---
# Add data labels (tooltips) above each bar
for count, rect in zip(counts, patches):
    height = rect.get_height()
    if height > 0:
        ax.text(
            rect.get_x() + rect.get_width() / 2,
            height + 5,  # Place label slightly above the bar
            f'{int(count)}',
            ha='center',
            va='bottom',
            fontsize=9
        )

# Add a vertical line for the Overall AOV
ax.axvline(
    overall_aov,
    color='red',
    linestyle='--',
    linewidth=2,
    label=f'Overall AOV: ${overall_aov:,.2f}'
)

# Set labels and title
ax.set_title(
    'Distribution of Average Order Value (AOV)',
    fontsize=16,
    fontweight='bold',
    pad=20
)
ax.set_xlabel('Order Total (USD)', fontsize=12)
ax.set_ylabel('Number of Orders (Frequency)', fontsize=12)

# Format x-axis ticks to be currency-like
formatter = plt.FuncFormatter(lambda x, p: f'${x:,.0f}')
ax.xaxis.set_major_formatter(formatter)
ax.legend()
ax.grid(axis='y', alpha=0.5)

plt.tight_layout()
plt.show()

# Assuming your dataframe is named 'df'
# If not, replace 'df' with your dataframe variable name

# Set seaborn style for colorful plots
sns.set(style="whitegrid")

# Create a boxplot for unit price distribution per product
plt.figure(figsize=(12, 6))
sns.boxplot(x='product_name', y='unit_price', data=df, palette='Set2')
plt.title('Unit Price Distribution Per Product')
plt.xlabel('Product Name')
plt.ylabel('Unit Price')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()

# Assuming your dataframe is named 'df'
# If not, replace 'df' with your dataframe variable name

# Group by state_name to calculate total revenue and order count
state_revenue = df_new.groupby('state_name')['revenue'].sum().reset_index()
state_orders = df_new.groupby('state_name').size().reset_index(name='order_count')

# Sort and get top 10 for revenue
top_revenue = state_revenue.sort_values(by='revenue', ascending=False).head(10)

# Sort and get top 10 for order count
top_orders = state_orders.sort_values(by='order_count', ascending=False).head(10)

# Set seaborn style for colorful plots
sns.set(style="whitegrid")

# Plot top 10 states by revenue
plt.figure(figsize=(12, 6))
sns.barplot(x='revenue', y='state_name', data=top_revenue, palette='viridis')
plt.title('Top 10 States by Total Revenue')
plt.xlabel('Total Revenue')
plt.ylabel('State Name')
plt.show()

# Plot top 10 states by order count
plt.figure(figsize=(12, 6))
sns.barplot(x='order_count', y='state_name', data=top_orders, palette='plasma')
plt.title('Top 10 States by Order Count')
plt.xlabel('Order Count')
plt.ylabel('State Name')
plt.show()

# Assuming your dataframe is named 'df'
# If not, replace 'df' with your dataframe variable name

# Group by channel to calculate average profit margin
avg_profit_margin = df_new.groupby('channel')['profit_margin_pct'].mean().reset_index()

# Set seaborn style for colorful plots
sns.set(style="whitegrid")

# Create a barplot for average profit margin by channel
plt.figure(figsize=(12, 6))
sns.barplot(x='profit_margin_pct', y='channel', data=avg_profit_margin, palette='magma')
plt.title('Average Profit Margin by Channel')
plt.xlabel('Average Profit Margin (%)')
plt.ylabel('Channel')
plt.tight_layout()
plt.show()